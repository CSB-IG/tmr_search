#' ssmarina
#'
#' This function performs marina on a single sample basis
#'
#' @param eset Numeric matrix containing the expression data or gene expression signatures, with samples in columns and genes in rows
#' @param regulon Object of class regulon
#' @param dnull Numeric matrix for the null model, usually generated by \code{nullTtest}
#' @param tw Number indicating the power transformation for target weight
#' @param lw Number indicating the power transformation for the likelihood weight
#' @param nes Logical, whether the enrichment score reported should be normalized
#' @param method Character string indicating the method for computing the single samples signature, either scale, rank, mad, ttest or none
#' @param minsize Integer indicating the minimum number of targets allowed per regulon
#' @param adaptive.size Logical, whether the weighting scores should be taken into account for computing the regulon size
#' @param eset.filter Logical, whether the dataset should be limited only to the genes represented in the interactome
#' @param nes.method Character string indicating the method for estimating the NES, either analytical, empirical or fit. Fit method is recommended only for large datasets (>500 samples)
#' @param verbose Logical, whether progression messages should be printed in the terminal
#' @return A matrix of inferred activity for each regulator gene in the network across all samples
#' @seealso \code{\link{marina}}
#' @export

ssmarina <- function(eset, regulon, dnull=NULL, tw=.5, lw=1, nes=T, method=c("scale", "rank", "mad", "ttest", "none")[1], minsize=25, adaptive.size=F, eset.filter=T, nes.method="analytic", verbose=T) {
  if (class(eset)=="ssmarinaSignature") {
    dnull <- eset$nullmodel
    eset <- eset$signature
    method="none"
  } else if (is.data.frame(eset)) {
	  eset<-as.matrix(eset)
  }
  
  if (eset.filter) eset <- eset[rownames(eset) %in% unique(c(names(regulon), unlist(lapply(regulon, function(x) names(x$tfmode)), use.names=F))), ]
  if (verbose) cat("\nComputing the association scores\n")
	switch(pmatch(method, c("scale", "rank", "mad", "ttest", "none")),
		tt <- t(scale(t(eset))),
		tt <- t(apply(eset, 1, rank))*punif(length(eset), -.1, .1),
		tt <- t(apply(eset, 1, function(x) (x-median(x))/mad(x))),
		{tt <- sapply(1:ncol(eset), function(i, eset) rowTtest(eset[, i]-eset[, -i])$statistic, eset=eset); colnames(tt) <- colnames(eset); rownames(tt) <- rownames(eset)},
		tt <- eset
	)
  regulon <- lapply(regulon, function(x, genes) {
    filtro <- names(x$tfmode) %in% genes
    x$tfmode <- x$tfmode[filtro]
    if(length(x$likelihood)==length(filtro)) x$likelihood <- x$likelihood[filtro]
    return(x)
  }, genes=rownames(eset))
	tw <- 1/table(unlist(lapply(regulon, function(x) names(x$tfmode)), use.names = F))^tw
	if (adaptive.size) regulon <- regulon[sapply(regulon, function(x, tw) {t1 <- tw[match(names(x$tfmode), names(tw))]; sum(x$likelihood*t1/max(x$likelihood*t1))}, tw=tw)>=minsize]
	else regulon <- regulon[sapply(regulon, function(x) length(x$tfmode))>=minsize]
  es <- pwea3NULLgroups(tt, regulon, tw=tw, lw=lw, verbose=verbose)
  if (!nes) {nes <- es$groups*es$ss; colnames(nes) <- colnames(eset); return(nes)}
  if (is.null(dnull)) switch(pmatch(nes.method, c("analytical", "empirical", "fit")),
  dnull <- ppwea3NULLf(regulon, tw=tw, lw=lw),
  dnull <- pwea3NULLf(es, verbose=verbose),
  dnull <- pwea3NULLf1(es))
  else dnull <- pwea3NULLf(pwea3NULLgroups(dnull, regulon, tw=tw, lw=lw, verbose=verbose), verbose=verbose)
  pval <- t(sapply(1:length(dnull), function(i, es, dnull) dnull[[i]](es[i, ])$p.value, es=es$groups, dnull=dnull)) 
  nes <- qnorm(pval/2, lower.tail=F)*es$ss
  rownames(nes) <- names(regulon)
  colnames(nes) <- colnames(eset)
  return(nes)
}

#' Signature and sample-permutation null model for ssmarina
#' 
#' This function generates a ssmarinaSignature object from a test dataset based on a set of samples to use as reference
#' 
#' @param eset Numeric matrix containing the test dataset, with genes in rows and samples in columns
#' @param ref Numeric matrix containing the reference samples (columns) and genes in rows
#' @param per Integer indicating the number of sample permutations
#' @param seed Integer indicating the seed for the random sample generation. The system default is used when set to zero
#' @param verbose Logical, whether progression messages should be printed in the terminal
#' @return ssmarinaSignature S3 object containing the signature and null model
#' @export

ssmarinaSignature <- function(eset, ref, per=1000, seed=1, verbose=T) {
  if (seed>0) set.seed(ceiling(seed))
  pb <- NULL
  if (verbose) pb <- txtProgressBar(max=per, style=3)
  vpsig <- apply(eset, 2, function(x, ctrl) {
    tmp <- rowTtest(x-ctrl)
    (qnorm(tmp$p.value/2, lower.tail=F)*sign(tmp$statistic))[, 1]
  }, ctrl=ref)
  rownames(vpsig) <- rownames(eset)
  colnames(vpsig) <- colnames(eset)
  vpnull <- sapply(1:1000, function(i, dset, pb, size, verbose) {
    if (verbose) setTxtProgressBar(pb, i)
    tmp <- NA
    while(any(is.na(tmp))) {
      pos <- sample(ncol(dset), size)
      tmp <- rowTtest(dset[, pos[1]]-dset[, pos[-1]])
      tmp <- (qnorm(tmp$p.value/2, lower.tail=F)*sign(tmp$statistic))[, 1]
    }
    return(tmp)
  }, dset=cbind(eset, ref), size=ncol(ref)+1, pb=pb, verbose=verbose)
  rownames(vpnull) <- rownames(eset)
  tmp <- list(signature=vpsig, nullmodel=vpnull)
  class(tmp) <- "ssmarinaSignature"
  return(tmp)
}
