#General functions for marina

#' Coefficient of variation filter
#'
#' This function filter redundant probes based on the highest coefficient of variation
#'
#' @param expset Matrix containing the gene expression data, with samples in columns and probes in rows. The \code{colnames} attribute should contain the sample names and the \code{rownames} attribute should contain the unique geneIDs
#' @return CV filtered dataset
#' @export

filterCV <- function (expset) {
 repet <- tapply(rownames(expset), factor(rownames(expset)), length)
  if (max(repet)>1) {
    d <- expset[rownames(expset) %in% (names(repet)[repet==1]),]  
    d1 <- expset[rownames(expset) %in% (names(repet)[repet>1]),]
    d2 <- tapply(1:nrow(d1),factor(rownames(d1)), function(pos, d1, cv) {
      list(name=rownames(d1)[pos][which.max(cv[pos])],value=d1[pos,][which.max(cv[pos]),])
    }, d1=d1, cv=frcv(d1))
    d3 <- t(sapply(d2, function(x) x$value))
    if (nrow(d3) != length(d2)) d3 <- t(d3)
    rownames(d3) <- sapply(d2, function(x) x$name)
    expset <- rbind(d,d3)
  }
  expset
}

#' Null model by sample permutation testing
#'
#' This function perfomrs sample permutation and t-test to generate a null model
#'
#' @param x Matrix containing the test dataset
#' @param y Matrix containing the reference dataset
#' @param per Integer indicating the number of permutations
#' @param repos Logical, whether the permutations should be performed with reposition
#' @param seed Integer indicating the seed for the permutations, 0 for disable it
#' @param verbose Logical, whether progression messages should be printed in the terminal
#' @return Matrix of z-scores with genes in rows and permutations in columns
#' @seealso \code{\link{marina}}, \code{\link{ssmarina}}
#' @export

ttestNull <- function(x, y, per=1000, repos=T, seed=1, verbose=T) {
  if (seed>0) set.seed(round(seed))
  pb <- NULL
  if (verbose) {
    cat("\n", date(), "\nComputing the null model distribution by ", per, " permutations.\n", sep="")
    pb <- txtProgressBar(max=per, style=3)
  }
  res <- sapply(1:per, function(i, x, y, repos, pb, verbose) {
    if (verbose) setTxtProgressBar(pb, i)
		expset <- cbind(x, y)
		repeat{
      sorder <- sample(ncol(expset), replace=repos)
			if (length(unique(sorder[1:ncol(x)]))>1 & length(unique(sorder[-(1:ncol(x))]))>1) break
			if (verbose) cat("-")
		}
    x1 <- filterColMatrix(expset, sorder[1:ncol(x)])
    y1 <- filterColMatrix(expset, sorder[-(1:ncol(x))])
    largo <- frlengthna(x1)
    largoy <- frlengthna(y1)
    t <- ((rowMeans(x1, na.rm=T) - rowMeans(y1, na.rm=T))/sqrt(((largo - 1) *  rowVars(x1) + (largoy - 1) * rowVars(y1))/(largo + largoy - 2))/sqrt(1/largo + 1/largoy))[, 1]
    t <- qnorm(pt(abs(t), largo + largoy - 2, lower.tail = F), lower.tail=F)*sign(t)
    names(t) <- rownames(x)
    return(t)
  }, x=x, y=y, repos=repos, pb=pb, verbose=verbose)
  colnames(res) <- 1:per
  if (verbose) cat("\n", date(), "\n")
  return(res)
}

#' Bootstrapped signature by t-test
#'
#' This function generates a bootstrapped signature matrix by t-test
#'
#' @param x Matrix containing the test dataset
#' @param y Matrix containing the reference dataset
#' @param per Integer indicating the number of permutations
#' @param seed Integer indicating the seed for the permutations, 0 for disable it
#' #' @param verbose Logical, whether progression messages should be printed in the terminal
#' @return Matrix of z-scores with genes in rows and permutations in columns
#' @seealso \code{\link{marina}}
#' @export

bootstrapTtest <- function(x, y, per=100, seed=1, verbose=T) {
  if (seed>0) set.seed(round(seed))
  pb <- NULL
  if (verbose) {
    cat("\n", date(), "\nComputing the bootstrapped signatures by ", per, " permutations.\n", sep="")
    pb <- txtProgressBar(max=per, style=3)
  }
  res <- sapply(1:per, function(i, x, y, pb, verbose) {
    if (verbose) setTxtProgressBar(pb, i)
    x1 <- filterColMatrix(x, sample(ncol(x), replace=T))
    y1 <- filterColMatrix(y, sample(ncol(y), replace=T))
    largo <- frlengthna(x1)
    largoy <- frlengthna(y1)
    t <- ((rowMeans(x1, na.rm=T) - rowMeans(y1, na.rm=T))/sqrt(((largo - 1) *  rowVars(x1) + (largoy - 1) * rowVars(y1))/(largo + largoy - 2))/sqrt(1/largo + 1/largoy))[, 1]
    t <- qnorm(pt(abs(t), largo + largoy - 2, lower.tail = F), lower.tail=F)*sign(t)
    names(t) <- rownames(x1)
    return(t)
  }, x=x, y=y, pb=pb, verbose=verbose)
  colnames(res) <- 1:per
  if (verbose) cat("\n", date(),"\n")
  return(res)
}

#' MARINa annotation change
#'
#' This function changes the annotation of genes in MARINa objects
#'
#' @param mobj MARINa object generated by \code{marina} function
#' @param annot Vector os character strings containing the gene names and gene identifiers as vector names attribute
#' @param complete Logical, whether the signature and target names should be also transformed
#' @return MARINa object with updated annotations
#' @seealso \code{\link{marina}}
#' @export

marinaAnnot <- function(mobj, annot, complete=T) {
  names(mobj$regulon) <- comNames(names(mobj$regulon), annot)
  mobj$regulon <- mobj$regulon[!is.na(names(mobj$regulon))]
	mobj$es <- lapply(mobj$es[sapply(mobj$es, length)>0], function(x, annot) {names(x) <- comNames(names(x), annot); x <- x[!is.na(names(x))]; return(x)}, annot=annot)
  if (complete) {
    if (is.null(dim(mobj$signature))) {names(mobj$signature) <- annot[match(names(mobj$signature), names(annot))]; mobj$signature <- mobj$signature[!is.na(names(mobj$signature))]}
    else {rownames(mobj$signature) <- annot[match(rownames(mobj$signature), names(annot))]; mobj$signature <- filterRowMatrix(mobj$signature, !is.na(rownames(mobj$signature)))}
    mobj$regulon <- lapply(mobj$regulon, function(x, annot) {names(x$tfmode) <- annot[match(names(x$tfmode), names(annot))]; filtro <- !is.na(names(x$tfmode)); x$tfmode <- x$tfmode[filtro]; x$likelihood <- x$likelihood[filtro]; x}, annot=annot)
    if (!is.null(mobj$nullmodel)) {rownames(mobj$nullmodel) <- annot[match(rownames(mobj$nullmodel), names(annot))]; mobj$nullmodel <- mobj$nullmodel[!is.na(rownames(mobj$nullmodel)), ]}
  }
  return(mobj)
}

#' Combinatorial annotation
#'
#' This function convers combinatorial annotations
#'
#' @param x Character vector of gene name combinations, where the combinations are separated by --
#' @param annot Vector of gene names with geneID as \code{names} attribute
#' @return Converted annotations
#' @seealso \code{\link{marina}}

comNames <- function(x, annot) sapply(strsplit(as.character(x), "--"), function(x, annot) paste(annot[match(x, names(annot))], collapse="--"), annot=annot)

rowVars <- function(x) 
{
    ave <- rowMeans(x, na.rm=T)
    pos <- which(is.na(x))
    largo <- frlengthna(x)
    x[pos] <- rep(ave, ncol(x))[pos]
    (x - ave)^2 %*% rep(1, ncol(x))/(largo - 1)
}

#' Prune Regulons
#' 
#' This function limits the maximum size of the regulons
#' 
#' @param regulon Object of class regulon
#' @param cutoff Number indicating the maximum size for the regulons (maximum number of target genes)
#' @param eliminate Logical whether regulons smalles than \code{cutoff} should be eliminated
#' @return Prunned regulon
#' @seealso \code{\link{ssmarina}}, \code{\link{marina}}
#' @export
pruneRegulon <- function(regulon, cutoff=50, eliminate=F) {
  regulon <- lapply(regulon, function(x, cutoff) {
    pos <- order(x$likelihood, decreasing=T)
    sc <- cumsum(x$likelihood[pos]/max(x$likelihood))
    if (max(sc)>cutoff) pos <- pos[1:(which(sc>=cutoff)[1])]
    return(list(tfmode=x$tfmode[pos], likelihood=x$likelihood[pos]))
  }, cutoff=cutoff)
  if (eliminate) regulon <- regulon[sapply(regulon, function(x) sum(x$likelihood)/max(x$likelihood))>=cutoff]
  return(regulon)
}

#' Integrate signatures
#' 
#' This function integrates signatures represented as columns in the input matrix using self-weighting average
#' 
#' @param signature Numeric matrix containing the signatures as z-scores or NES, genes in rows and signatures in columns
#' @param score Number indicating the exponent score for the weight
#' @return Vector containing the integrated signatures
#' @export
integrateSignatures <- function(signature, score=1) {
  w <- abs(signature)^score
  w <- w/rowSums(w)
  return(rowSums(signature*w))
}

#' Length of rows for arrays with NA values
#'
#' This function report the length of rows of a matrix ignoring the NA values
#'
#' @param x Matrix
#' @return 1-column matrix of integers indicating the number of non-NA rows
#' @export

frlengthna <- function(x) {
  r <- x/x
  r[x==0] <- 1
  r[!is.finite(r)] <- 0
  r %*% rep(1, ncol(r))
}

#' Length of columns of arrays with NAs
#'
#' This function report the number of columns of a matrix ignoring NA values
#'
#' @param x Matrix
#' @return 1-column matrix of integers indicating the number of non-NA columns
#' @export

fclengthna <- function(x) frlengthna(t(x))

#' Sum by rows
#'
#' This function performs a sum by rows ignoring NA values
#'
#' @param x Numeric matrix
#' @return 1-column matrix with the sum by row results
#' @export

frsumna <- function(x) {
        x[is.na(x)] <- 0
        res <- x %*% rep(1, ncol(x))
        names(res) <- rownames(x)
        res
}

#' Sum by columns
#'
#' This function performs a sum by columns ignoring NA values
#'
#' @param x Numeric matrix
#' @return 1-column matrix with the sum by column results
#' @export

fcsumna <- function(x) frsumna(t(x))

#' Mean of rows for arrays with NA values
#'
#' This function compute the mean by rows ignoring NA values
#'
#' @param x Numeric matrix
#' @return 1-column matrix with the mean by row resultsNumeric vector
#' @export

frmeanna <- function(x) {
  largo <- frlengthna(x)
  x[is.na(x)] <- 0
  res <- x %*% rep(1,ncol(x)) / largo
  names(res) <- rownames(x)
  res
}

#' Mean of columns for arrays with NA values
#'
#' This function computes the mean by columns ignoring NA values
#'
#' @param x Numeric matrix
#' @return 1 columns matrix with the mean by column results
#' @export

fcmeanna <- function(x) frmeanna(t(x))

#' Variance of rows for arrays with NA values
#'
#' This function computes the variance by rows ignoring NA values
#'
#' @param x Numeric matrix
#' @return 1-column matrix with the variance by row results
#' @export
frvarna <- function(x) {
  ave <- as.vector(frmeanna(x))
  pos <- which(is.na(x))
  largo <- frlengthna(x)
  x[pos] <- rep(ave, ncol(x))[pos]
  (x-ave)^2 %*% rep(1,ncol(x))/(largo-1)
}

#' Variance of columns for arrays with NA values
#'
#' This function computes the variance by columns ignoring NA values
#'
#' @param x Numeric matrix
#' @return 1-column matrix with the variance by column results
#' @export
fcvarna <- function(x) frvarna(t(x))

#' Student's t-test for rows
#' 
#' This function performs a Student's t-test on each row of a matrix
#' 
#' @param x Numerical matrix containing the test samples
#' @param y Optional numerical matrix containing the reference samples. If ommited \code{x} will be tested against mean = \code{mu}
#' @param mu Number indicating the alternative hypothesis when \code{y} is ommited
#' @param alternative Character string indicating the tail for the test, either two.sided, greater or lower
#' @return List of Student-t-statistic (\code{statistic}) and p-values (\code{p.value})
#' @export
rowTtest <- function(x, y=NULL, mu=0, alternative="two.sided") {
  largo <- frlengthna(x)
  if (is.null(y)) {
    t <- (frmeanna(x)-mu)/sqrt(frvarna(x)/largo)
    list(statistic=t, p.value=switch(pmatch(alternative, c("two.sided", "greater", "less")), pt(abs(t),largo-1,lower.tail=F)*2, pt(t, largo-1, lower.tail=F), pt(t, largo-1, lower.tail=T)))
  }
  else {
    largoy <- frlengthna(y)
    t <- (frmeanna(x)-frmeanna(y))/sqrt(((largo-1)*frvarna(x)+(largoy-1)*frvarna(y))/(largo+largoy-2))/sqrt(1/largo+1/largoy)
    list(statistic=t, p.value=switch(pmatch(alternative, c("two.sided", "greater", "less")), pt(abs(t),largo+largoy-2,lower.tail=F)*2, pt(t, largo+largoy-2, lower.tail=F), pt(t, largo+largoy-2, lower.tail=T)))
  }
}

#' Coeficient of variations for rows
#'
#' This function computes the coefficient of variation (CV) by rows
#'
#' @param x Numeric matrix
#' @return 1-column matrix with the coefficient of variation by row results
#' @export

frcv <- function(x) sqrt(frvarna(x))/frmeanna(x)

#' Loading expression sets
#' 
#' This function load an expression file into a matrix
#' 
#' @param filename Character string indicating the name of the expression file
#' @return List containing a numeric matrix of expression data with samples in columns and probes in rows; and a vector of gene mapping annotations
loadExpset <- function(filename) {
  tmp <- strsplit(readLines(filename), "\t")
  d1 <- t(sapply(tmp[-1], function(x) as.numeric(x[-(1:2)])))
  colnames(d1) <- tmp[[1]][-(1:2)]
  rownames(d1) <- sapply(tmp[-1], function(x) x[1])
  annot <- sapply(tmp[-1], function(x) x[2])
  names(annot) <- rownames(d1)
  return(list(expset=d1, annot=annot))
}
