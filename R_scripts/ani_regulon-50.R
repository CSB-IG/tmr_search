#############  REGULONES  #############

######## LOADS ########

library(mixtools)

setwd("~/MARINa")
load("./Rdatas/dset.RData")

print("Source and data set loaded")

#######################################
############# Set functions ##############
#######################################

#' Regulon object generation from ARACNe results
#' 
#' This function generates a regulon object from ARACNe results and the corresponding expression dataset
#' 
#' @param afile Character string indicating the name of the ARACNe network file
#' @param eset Either a character string indicating the name of the expression-dataset file, or a gene expression matrix with genes (probes) in rows and samples in columns
#' @param gene Logical, whether the probes should be collapsed at the gene level
#' @param format Character string, indicating the format of the aracne file, either adj for adjacency matrixes generated by aracne, or 3col when the interactome is represented by a 3 columns text file, with regulator in the first column, target in the second and mutual information in the third column
#' @param verbose Logical, whether progression messages should be printed in the terminal.
#' @return Regulon object
#' @seealso \code{\link{marina}}, \code{\link{ssmarina}}
#' @export
aracne2regulon <- function(afile, eset, gene=F, format=c("adj", "3col")[1], verbose=T) {
	require(mixtools)
	if (verbose) cat("\nLoading the dataset...")
  if (length(eset)==1) {
    tmp <- strsplit(readLines(eset), "\t")
    dset <- t(sapply(tmp[-1], function(x) as.numeric(x[-(1:2)])))
    colnames(dset) <- tmp[[1]][-(1:2)]
    rownames(dset) <- sapply(tmp[-1], function(x) x[1])
    annot <- t(sapply(tmp[-1], function(x) x[1:2]))
  }
  else {
    dset <- eset
    annot <- rownames(eset)
    names(annot) <- rownames(eset)
    rm(eset)
  }
  #Collapsing interactomes
  switch(match.arg(format, c("adj", "3col")),
    adj={
      aracne <- readAracneAdj(afile)
    },
    "3col"={
      tmp <- t(sapply(strsplit(readLines(afile), "\t"), function(x) x[1:3]))
      aracne <- data.frame(tf=tmp[, 1], target=tmp[, 2], mi=as.numeric(tmp[, 3])/max(as.numeric(tmp[, 3])))
    })
  if (gene) {
	  if (verbose) cat("\nCollapsing the interactomes to the gene level...")
	  tmp <- tmp[order(tmp$mi, decreasing=T), ]
	  tmp$tf <- annot[match(tmp$tf, annot[, 1]), 2]
	  tmp$target <- annot[match(tmp$target, annot[, 1]), 2]
	  aracne <- tmp[!duplicated(paste(tmp$tf, tmp$target, sep="_")), ]
	#Generating the gene centric datasets
	  rownames(dset) <- annot[match(rownames(dset), annot[, 1]), 2]
	  dset <- filterCV(dset)
	}
  if (verbose) cat("\nGenerating the regulon objects...")
	tmp <- aracne[!is.na(aracne$mi), ]
	aracne <- tapply(1:nrow(tmp), tmp$tf, function(pos, tmp) {
	  tfmode <- rep(0, length(pos))
	  names(tfmode) <- tmp$target[pos]
	  list(tfmode=tfmode, likelihood=tmp$mi[pos])
	}, tmp=tmp)
	names(aracne) <- levels(tmp$tf)
	aracne <- TFmode1(aracne, dset)
  rm(dset)
# removing missing data from the aracne regulon
	aracne <- aracne[names(aracne) != "NA"]
	aracne <- lapply(aracne, function(x) {filtro <- !(names(x$tfmode)=="NA" | is.na(x$tfmode) | is.na(x$likelihood)); x$tfmode <- x$tfmode[filtro]; x$likelihood <- x$likelihood[filtro]; x})
	aracne <- aracne[sapply(aracne, function(x) length(names(x$tfmode)))>0]
  regul <- TFscore(aracne, verbose=verbose)
  class(regul) <- "regulon"
  return(regul)
}

#' @method print regulon
#' @S3method print regulon
print.regulon <- function(x, ...) {
  cat("Object of class regulon with ", length(x), " regulators, ", length(unique(unlist(lapply(x, function(x) names(x$tfmode)), use.names=F))), " targets and ", length(unlist(lapply(x, function(x) names(x$tfmode)), use.names=F)), " interactions\n", sep="")
}

#' @method summary regulon
#' @S3method summary regulon
summary.regulon <- function(object, ...) {
  c(Regulators=length(object), Targets=length(unique(unlist(lapply(object, function(x) names(x$tfmode)), use.names=F))), Interactions=length(unlist(lapply(object, function(x) names(x$tfmode)), use.names=F)))
}

TFmode1 <- function (regulon, expset, method = "spearman") {
  expset <- filterCV(expset)
  regulon <- updateRegulon(regulon)
  regulon <- regulon[names(regulon) %in% rownames(expset)]
  regulon <- lapply(regulon, function(x, genes) {
    filtro <- names(x$tfmode) %in% genes
    x$tfmode <- x$tfmode[filtro]
    if (length(x$likelihood) == length(filtro)) 
      x$likelihood <- x$likelihood[filtro]
    return(x)
  }, genes = rownames(expset))
  tf <- unique(names(regulon))
  tg <- unique(unlist(lapply(regulon, function(x) names(x$tfmode)), use.names = F))
  cmat <- cor(t(expset[rownames(expset) %in% tf, ]), t(expset[rownames(expset) %in% tg, ]), method = method)
  reg <- lapply(1:length(regulon), function(i, regulon, cmat) {
    tfscore <- cmat[which(rownames(cmat) == names(regulon)[i]), match(names(regulon[[i]]$tfmode), colnames(cmat))]
    list(tfmode = tfscore, likelihood = regulon[[i]]$likelihood)
  }, regulon = regulon, cmat = cmat)
  names(reg) <- names(regulon)
  return(reg)
}

TFscore <- function (regul, mu = NULL, sigma = NULL, verbose=T) {
  if (length(mu) == 3 & length(sigma) == 3)
    fit <- list(mu = mu, sigma = sigma)
  else {
    require(mixtools)
    tmp <- unlist(lapply(regul, function(x) x$tfmode), use.names = F)
    fit <- list(mu = c(-0.5, 0, 0.5), sigma = c(0.15, 0.25, 0.15), lambda = c(0.2, 0.4, 0.4), all.loglik = rep(0, 10001))
    while (length(fit$all.loglik) > 10000) fit <- normalmixEM(tmp, mu = fit$mu, sigma = fit$sigma, lambda = fit$lambda, mean.constr = c(NA, 0, NA), maxit = 10000, verb = F)
  }
  if (verbose) cat("\nmu: ", paste(fit$mu, collapse = ", "), ". sigma: ", paste(fit$sigma, collapse = ", "), ".\n", sep = "")
  regul <- lapply(regul, function(x, fit) {
    x$tfmode <- pnorm(x$tfmode, fit$mu[3], fit$sigma[3], lower.tail = T)/(pnorm(x$tfmode, fit$mu[1], fit$sigma[1], lower.tail = F) + pnorm(x$tfmode, fit$mu[2], fit$sigma[2], lower.tail = F) + pnorm(x$tfmode, fit$mu[3], fit$sigma[3], lower.tail = T)) * (x$tfmode >= 0) - pnorm(x$tfmode, fit$mu[1], fit$sigma[1], lower.tail = F)/(pnorm(x$tfmode, fit$mu[1], fit$sigma[1], lower.tail = F) + pnorm(x$tfmode, 
fit$mu[2], fit$sigma[2], lower.tail = T) + pnorm(x$tfmode, fit$mu[3], fit$sigma[3], lower.tail = T)) * (x$tfmode < 0)
    return(x)
  }, fit = fit)
  return(regul)
}

readAracneAdj <- function(fname) {
  tmp <- readLines(fname)
  pos <- grep(">", tmp)
  if (length(pos)>0) tmp <- tmp[-pos]
  tmp <- strsplit(tmp, "\t")
  nom <- sapply(tmp, function(x) x[1])
  tmp <- lapply(tmp, function(x) matrix(x[-1], length(x[-1])/2, 2, byrow=T))
  aracne <- data.frame(tf=rep(nom, sapply(tmp, nrow)), target=unlist(lapply(tmp, function(x) x[, 1]), use.names=F), mi=as.numeric(unlist(lapply(tmp, function(x) x[, 2]), use.names=F)))
  return(aracne)
}

filterCV <- function (expset) {
 repet <- tapply(rownames(expset), factor(rownames(expset)), length)
  if (max(repet)>1) {
    d <- expset[rownames(expset) %in% (names(repet)[repet==1]),]  
    d1 <- expset[rownames(expset) %in% (names(repet)[repet>1]),]
    d2 <- tapply(1:nrow(d1),factor(rownames(d1)), function(pos, d1, cv) {
      list(name=rownames(d1)[pos][which.max(cv[pos])],value=d1[pos,][which.max(cv[pos]),])
    }, d1=d1, cv=frcv(d1))
    d3 <- t(sapply(d2, function(x) x$value))
    if (nrow(d3) != length(d2)) d3 <- t(d3)
    rownames(d3) <- sapply(d2, function(x) x$name)
    expset <- rbind(d,d3)
  }
  expset
}

updateRegulon <- function(regul) {
  if (is.null(names(regul[[1]]))) return(lapply(regul, function(x) {tmp <- rep(0, length(x)); names(tmp) <- x; list(tfmode=tmp, likelihood=rep(1, length(tmp)))}))
  if (names(regul[[1]])[1]=="tfmode") return(regul)
  return(lapply(regul, function(x) list(tfmode=x, likelihood=rep(1, length(x)))))
}


print("functions loaded")

######## PRUEBA ########

#library(bcellExample)
#data(bcellExample)
#adjfile <- file.path(find.package("bcellExample"), "aracne", "bcellaracne.adj")
#regul <- aracne2regulon(adjfile, dset)


######## CALCULATE REGULON ########
### One proces by TF list

# adj from ARACNe imput data

atfdb_adjfile <- file.path("/home/hachepunto/transfac_network/adjs_prunned/AnimalTFDB_p1e-50.adj")
print("adj loaded")

##########################
to_clean <- ls()
##########################

# Regulon generation
print("proced to compute the regulon")
ani_regulon_50 <- aracne2regulon(atfdb_adjfile, dset)

print("regulon computed")

#######################################
############### S A V E ################
#######################################

print("proced to Save Regulon animal tfdb 50")
rm(list=to_clean,to_clean) #cleaning
save(ani_regulon_50, file = "./Rdatas/ani_regulon_50.RData")

print("All Done!!")